Ethical considerations of dba:
Transparency: When you collect information, you should tell the owners of the information exactly what data you will collect and what you will do with it. Inform them about how you use the data, how you store it, who will have access to it, and how you will dispose of it when you have finished using it.
Consent: You should get clear consent from data owners before you collect their data. This should detail what data you will be allowed to collect and how you will be allowed to use it.
Integrity: Always be clear about your procedures and policies, and always follow them consistently. As far as you can, make sure that others in your organization also follow the correct procedures and policies.

A storage engine is a software component that handles the operations that store and manage information in a database. MySQL is unusual among relational databases because it supports multiple storage engines.

Each storage engine has a particular set of operational characteristics, including the types of locks to manage query contention and whether the storage engine supports transactions. These properties have implications for database performance, so choose your storage engine based on the type of data you want to store and the operations you want to perform.

Most applications require only one storage engine for the whole database, but you can specify the storage engine on a table-by-table basis if your data has different requirements.

Storage engines available in MySQL
Engines

Description

InnoDB

Default storage engine for MySQL 5.5 and later.
Suitable for most data storage scenarios.
Provides ACID-compliant tables and FOREIGN KEY referential-integrity constraints.
Supports commit, rollback, and crash recovery capabilities to protect data.
Supports row-level locking.
Stores data in clustered indexes which reduces I/O for queries based on primary keys.
MyISAM

Manages non-transactional tables.
Provides high-speed storage and retrieval.
Supports full-text searching.
MEMORY

Provides in-memory tables, formerly known as HEAP.
Stores all data in RAM for faster access than storing data on disks.
Useful for quick lookups of reference and other identical data.
MERGE

Treats groups of similar MyISAM tables as a single table.
Handles non-transactional tables.
EXAMPLE

Allows developers to practice creating a new storage engine.
Allows developers to create tables.
Does not store or fetch data.
ARCHIVE

Stores a large amount of data.
Does not support indexes.
CSV

Stores data in Comma Separated Value format in a text file.
BLACKHOLE

Accepts data to store but always returns empty.
FEDERATED

Stores data in a remote database.
Commands for working with Storage Engines
If you’re a DBA working with storage engines in MySQL, you should be familiar with the following common commands.

SHOW ENGINES
Displays status information about the server’s storage engines. Useful for checking whether a storage engine is supported, or what the default engine is.

mysql> SHOW ENGINES;

Screenshot shows status information of server storage engines

CREATE TABLE
Creates a table using the storage engine specified in the ENGINE clause, as shown in the following examples:

CREATE TABLE Products (i INT) ENGINE = INNODB;

CREATE TABLE Product_Codes (i INT) ENGINE = CSV;

CREATE TABLE History (i INT) ENGINE = MEMORY;

If you do not specify the ENGINE clause, the CREATE TABLE statement creates the table with the default storage engine, usually InnoDB.

SET
For databases with non-standard storage needs, you can specify a different default storage engine using the set command.

Set the default storage engine for the current session by setting the default_storage_engine variable using the SET command. For example, if you are creating a database to store archived data, you can use the following command:

SET default_storage_engine=ARCHIVE;

To set the default storage engine for all sessions, set the default-storage-engine option in the my.cnf configuration file.

ALTER TABLE
You can convert a table from one storage engine to another using an ALTER TABLE statement. For example, the following statement set the storage enigne for the Products table to Memory:

ALTER TABLE Products ENGINE = MEMORY;

InnoDB is suitable for most data storage needs but setting and working with different storage engines in MYSQL gives you more control over how your data is stored and accessed. Using the most appropriate storage engine for your data brings operational benefits like faster response times or efficient use of available storage.

================================================================================================

User Management and Access Control in PostgreSQL

NOTE: he postgres superuser may not be appropriate as it bypasses all permission checks, which carries inherent risk

Objectives

Create roles in a database and grant them select permissions
Create new users in the database and assign them the appropriate role
Revoke and deny access to the database from a user

use a database from https://postgrespro.com/education/demodb

============================================
DB Monitoring Involves:
To perform several database monitoring tasks, including: Forecasting your future hardware requirements based on database usage patterns. Analyzing the performance of individual applications or database queries. Tracking the usage of indexes and tables. Determining the root cause of any system performance degradation. Optimizing database
elements to provide the best possible performance. And assessing the impact of any optimization activities.

Proactive Monitoring involves:

Proactive monitoring typically utilizes automated processes to perform tasks such as regularly verifying that a database system is online and accessible, verifying that configuration changes do not adversely affect the performance of the database system, and that the database system is operating and performing at acceptable levels. This proactive approach is widely considered to be the better strategy and is preferred by most database admins. To determine whether your database system is performing at its most optimal, you first need to establish a baseline for your database system’s performance.

Even when things are working well, and as expected, you can still use your performance baseline data to help you determine operational norms, such as your peak and off-peak hours of operation, typical response times for running queries and processing batch commands, and the time taken to perform database backup and restore operations. The following areas typically have the greatest effect on the performance of your database system: System hardware resources, network architecture, operating system, database applications, and client applications. There are two ways to monitor operations in your database.

-------------------------------------

There are many types of indexes that you can add to your databases, with popular ones being regular indexes, primary indexes, unique indexes, full-text indexes and prefix indexes.

Type of Index	Description
Regular Index	An index where values do not have to be unique and can be NULL.
Primary Index	Primary indexes are automatically created for primary keys. All column values are unique and NULL values are not allowed.
Unique Index	An index where all column values are unique. Unlike the primary index, unique indexes can contain a NULL value.
Full-Text Index	An index used for searching through large amounts of text and can only be created for char, varchar and/or text datatype columns.
Prefix Index	An index that uses only the first N characters of a text value, which can improve performance as only those characters would need to be searched.

-----------------------------------------------------
Generally, it’s best practice to avoid adding indexes to all your columns, only adding them to the ones that it may be helpful for, such as a column that is frequently accessed. While indexing can improve the performance of some queries, it can also slow down your inserts, updates and deletes because each index will need to be updated every time. Therefore, it’s important to find the balance between the number of indexes and the speed of your queries.

In addition, indexes are less helpful for querying small tables or large tables where almost all the rows need to be examined. In the case where most rows need to be examined, it would be faster to read all those rows rather than using an index. As such, adding an index is dependent on your needs.

When possible, avoid selecting all columns from your table. With larger datasets, selecting all columns and displaying them can take much longer than selecting the one or two columns that you need.

For example, with a dataset of about 300,000 employee entries, the following query takes about 0.31 seconds to load:

SELECT * FROM employee;

But if we only wanted to see the employee numbers and their hire dates (2 out of the 6 columns) we could easily do so with this query that takes 0.12 seconds to load:

SELECT employee_number, hire_date FROM employee;

Notice how the execution time of the query is much faster compared to the when we selected them all. This method can be helpful when dealing with large datasets that you only need select specific columns from.

Use the UNION ALL Clause
When using the OR operator with LIKE statements, a UNION ALL clause can improve the speed of your query, especially if the columns on both sides of the operator are indexed.

This improvement is due to the OR operator sometimes scanning the entire table and overlooking indexes, whereas the UNION ALL operator will apply them to the separate SELECT statements.


